apiVersion: v1
kind: ConfigMap
metadata:
  name: clickhouse-logger-plugin
  namespace: {{ template "kong.namespace" . }}
  labels:
    {{- include "kong.metaLabels" . | nindent 4 }}
data:
  kong.plugin: |
    return {
      name = "clickhouse-logger",
      version = "1.0.0",
      priority = 1000
    }
  schema.lua: |
    local typedefs = require "kong.db.schema.typedefs"

    return {
        name = "clickhouse-logger",
        fields = {
            {
                consumer = typedefs.no_consumer
            },
            {
                config = {
                    type = "record",
                    fields = {
                        {
                            clickhouse_host = {
                                type = "string",
                                required = true,
                                default = "clickhouse-dev.clickhouse.svc.cluster.local"
                            }
                        },
                        {
                            clickhouse_port = {
                                type = "integer",
                                required = true,
                                default = 8123
                            }
                        },
                        {
                            clickhouse_user = {
                                type = "string",
                                required = true,
                                default = "kong"
                            }
                        },
                        {
                            clickhouse_password = {
                                type = "string",
                                required = true,
                                default = "P@ssw0rd"
                            }
                        },
                        {
                            database_name = {
                                type = "string",
                                required = true,
                                default = "kong"
                            }
                        },
                        {
                            table_name = {
                                type = "string",
                                required = true,
                                default = "request_logs"
                            }
                        },
                        {
                            log_request_headers = {
                                type = "boolean",
                                required = false,
                                default = true
                            }
                        },
                        {
                            log_request_body = {
                                type = "boolean",
                                required = false,
                                default = false
                            }
                        },
                        {
                            log_response_headers = {
                                type = "boolean",
                                required = false,
                                default = false
                            }
                        },
                        {
                            log_response_body = {
                                type = "boolean",
                                required = false,
                                default = false
                            }
                        },
                        {
                            timeout = {
                                type = "integer",
                                required = false,
                                default = 5000
                            }
                        },
                        {
                            keepalive = {
                                type = "integer",
                                required = false,
                                default = 30000
                            }
                        },
                        {
                            batch_size = {
                                type = "integer",
                                required = false,
                                default = 100
                            }
                        },
                        {
                            flush_timeout = {
                                type = "integer",
                                required = false,
                                default = 2
                            }
                        },
                        {
                            excluded_status_codes = {
                                type = "array",
                                elements = {
                                    type = "integer"
                                },
                                default = { 404, 401 }
                            }
                        }
                    }
                }
            }
        }
    }
  
  handler.lua: |
    local BasePlugin = require "kong.plugins.base_plugin"
    local http = require "resty.http"
    local cjson = require "cjson"
    local ngx = ngx
    local kong = kong

    local ClickhouseLoggerHandler = BasePlugin:extend()

    ClickhouseLoggerHandler.PRIORITY = 5
    ClickhouseLoggerHandler.VERSION = "1.0.0"

    -- 批量处理队列
    local log_queue = {}
    local queue_size = 0

    -- 创建 ClickHouse 表（如果不存在）
    local function create_clickhouse_table(config)
        local create_table_sql = string.format([[
        CREATE TABLE IF NOT EXISTS %s.kong_logs (
          timestamp DateTime64(3),
          service_name String,
          route_name String,
          consumer String,
          client_ip String,
          method String,
          path String,
          status_code UInt16,
          request_headers String,
          response_headers String,
          request_body String,
          response_body String,
          request_size UInt32,
          response_size UInt32,
          latency Float64,
          upstream_latency Float64,
          kong_latency Float64
        ) ENGINE = MergeTree()
        PARTITION BY toYYYYMM(timestamp)
        ORDER BY (timestamp, service_name, status_code)
        SETTINGS index_granularity = 8192
      ]], config.clickhouse_database)

        return create_table_sql
    end

    -- 发送数据到 ClickHouse
    local function send_to_clickhouse(config, log_data)
        local httpc = http.new()
        httpc:set_timeout(config.timeout)

        local ok, err = httpc:connect(config.clickhouse_host, config.clickhouse_port)
        if not ok then
            kong.log.err("Failed to connect to ClickHouse: ", err)
            return false
        end

        -- 构建 INSERT 查询
        local query = string.format([[
        INSERT INTO %s.%s (
          timestamp, service_name, route_name, consumer, client_ip, method, path,
          status_code, request_headers, response_headers, request_body, response_body,
          request_size, response_size, latency, upstream_latency, kong_latency
        ) FORMAT JSONEachRow
      ]], config.clickhouse_database, config.clickhouse_table)

        local res, err = httpc:request({
            method = "POST",
            path = "/?query=" .. ngx.escape_uri(query),
            body = log_data,
            headers = {
                ["Content-Type"] = "application/json",
                ["X-ClickHouse-User"] = config.clickhouse_user or "default",
                ["X-ClickHouse-Key"] = config.clickhouse_password or "",
            }
        })

        if not res then
            kong.log.err("Failed to send request to ClickHouse: ", err)
            httpc:close()
            return false
        end

        if res.status ~= 200 then
            local body = res:read_body()
            kong.log.err("ClickHouse error: ", body)
            httpc:close()
            return false
        end

        httpc:set_keepalive(config.keepalive)
        return true
    end

    -- 批量发送日志
    local function flush_logs(premature, config)
        if premature or queue_size == 0 then
            return
        end

        local logs_to_send = table.concat(log_queue, "\n")
        log_queue = {}
        queue_size = 0

        local success = send_to_clickhouse(config, logs_to_send)
        if not success then
            kong.log.err("Failed to flush logs to ClickHouse")
        end
    end

    -- 记录日志到队列
    local function queue_log(config, log_entry)
        local json_log = cjson.encode(log_entry)
        table.insert(log_queue, json_log)
        queue_size = queue_size + 1

        -- 达到批量大小时立即刷新
        if queue_size >= config.batch_size then
            flush_logs(false, config)
        end
    end

    function ClickhouseLoggerHandler:new()
        ClickhouseLoggerHandler.super.new(self, "clickhouse-logger")
    end

    -- 在请求开始时记录请求数据
    function ClickhouseLoggerHandler:access(config)
        ClickhouseLoggerHandler.super.access(self)

        local ctx = ngx.ctx
        ctx.clickhouse_logger = {
            config = config,
            started_at = ngx.now() * 1000, -- 转换为毫秒
            request_headers = {},
            request_body = ""
        }

        -- 记录请求头
        if config.log_request_headers then
            local headers = kong.request.get_headers()
            ctx.clickhouse_logger.request_headers = headers
        end

        -- 记录请求体
        if config.log_request_body then
            local body, err = kong.request.get_body()
            if not err and body then
                ctx.clickhouse_logger.request_body = cjson.encode(body)
            end
        end
    end

    -- 在响应头过滤时记录响应头
    function ClickhouseLoggerHandler:header_filter(config)
        ClickhouseLoggerHandler.super.header_filter(self)

        local ctx = ngx.ctx.clickhouse_logger
        if not ctx then return end

        if config.log_response_headers then
            local headers = kong.response.get_headers()
            ctx.response_headers = headers
        end
    end

    -- 在响应体过滤时记录响应体
    function ClickhouseLoggerHandler:body_filter(config)
        ClickhouseLoggerHandler.super.body_filter(self)

        local ctx = ngx.ctx.clickhouse_logger
        if not ctx then return end

        if config.log_response_body then
            local chunk = ngx.arg[1]
            if chunk then
                ctx.response_body = (ctx.response_body or "") .. chunk
            end
        end
    end

    -- 在日志阶段发送数据到 ClickHouse
    function ClickhouseLoggerHandler:log(config)
        ClickhouseLoggerHandler.super.log(self)

        local ctx = ngx.ctx.clickhouse_logger
        if not ctx then return end

        -- 检查是否在排除的状态码列表中
        local status = kong.response.get_status()
        for _, excluded_status in ipairs(config.excluded_status_codes) do
            if status == excluded_status then
                return
            end
        end

        local now = ngx.now() * 1000
        local latency = now - ctx.started_at

        -- 获取服务、路由和消费者信息
        local service
        local route
        local consumer

        if kong.ctx.shared.service then
            service = kong.ctx.shared.service.name or kong.ctx.shared.service.id
        end

        if kong.ctx.shared.route then
            route = kong.ctx.shared.route.name or kong.ctx.shared.route.id
        end

        if kong.ctx.shared.authenticated_consumer then
            consumer = kong.ctx.shared.authenticated_consumer.username or
                kong.ctx.shared.authenticated_consumer.id
        end

        -- 构建日志条目
        local log_entry = {
            timestamp = ngx.now() * 1000000, -- 微秒精度
            service_name = service or "",
            route_name = route or "",
            consumer = consumer or "",
            client_ip = kong.client.get_forwarded_ip(),
            method = kong.request.get_method(),
            path = kong.request.get_path(),
            status_code = status,
            request_headers = config.log_request_headers and cjson.encode(ctx.request_headers) or "",
            response_headers = config.log_response_headers and cjson.encode(ctx.response_headers) or "",
            request_body = config.log_request_body and ctx.request_body or "",
            response_body = config.log_response_body and ctx.response_body or "",
            request_size = tonumber(kong.request.get_header("Content-Length")) or 0,
            response_size = tonumber(kong.response.get_header("Content-Length")) or 0,
            latency = latency,
            upstream_latency = kong.ctx.shared.upstream_latency or 0,
            kong_latency = kong.ctx.shared.kong_latency or 0
        }

        -- 将日志加入队列
        queue_log(config, log_entry)

        -- 设置定时刷新
        if not ngx.timer.pending then
            local ok, err = ngx.timer.at(config.flush_timeout, flush_logs, config)
            if not ok then
                kong.log.err("Failed to create timer: ", err)
                flush_logs(false, config) -- 立即刷新
            end
        end
    end

    return ClickhouseLoggerHandler
